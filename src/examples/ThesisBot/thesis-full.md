
##ThesisBot Example
####Petr van Blokland

#Python for Designers

###50 ideas to start. Using BageBot.

##Introduction
This is course is about Python. If you now think that it’s about snakes and not about programming, you don’t want to continue. But if you are here with the expectation that you will learn about programming techniques and objects and classes dedicated for the design practice, then you are on the right track. By the way, you don’t have to be a designer by profession, in order to follow this course. It’s characteristic is that we really start from scratch, using daily life examples to visualize the programs. Their structure, their behavior and their usage. That is a different approach from many other programming courses, which often start with a technical solution in search for a problem. There will be a lot of coding in this course. But I’ll try my ultimate best to clarify as much as I can and to relate everything to practical problems that you can recognize and visualize. I am pretty sure that you will see that programming is not as magic as some programmers want you to believe. And what is more important, knowing about how programming works yourself, can actually save you a lot of time. Even if you don’t want to be a programmer. The course is set up as a growing environment. Because the development of a course like this is a design process in itself – increased knowledge and understanding about how it should be done – there will be continuous improvement on the code and the examples. Feedback from subscribers and the regular updates of Python make that the course will adapt and grow over time. So the subscription fee of the course will grow too. This makes the plan for course into an alternative construction of a kickstart project. If you are an early adapter, trusting that the course will grow and develop in a direction that you need, then you just pay the current amount. After that every addition is available free of charge. The Udemy courses always have a lifetime subscription for the fee that you initially paid for it. If you wait for a few months, more content will be added and the price will be subsequently higher, adding approximately $16 per hour video. Any time you jump on the bandwagon, you will pay the price as it is at that moment, based on the volume of the content at that moment. Relatively low in the beginning, putting your trust in the expectation we’ll develop the course further. We start with 2 hours of instructions and examples. If you wait for a while, you will pay more for the same content. So, if you are a designer, or you have other reasons to use Python in your professional life or your personal life, you are already using Python or you expect to do that in the future, then joining this growing environment is likely to be profitable for you. There are many good examples around showing the great potential of programming in Python, but most are solutions in search for a problem to be solved. Using programming in your daily practice requires a reversed approach. You want to achieve something and what is the best pattern this can be done. Instead of reading the translation of “Do you know where the station is?” in a tourist guide, you are interested in conversations in this foreign language where you can decide on the topic. This course is trying to do that. And since these patterns are so divers and changing overtime, you need an environment that will adapt and grow, instead of presenting a fixed “how to” course. At the end of the course an overview of possible future topics is given. This list will be maintained over time, adding wishes and needs expressed by you, the user of the course. The development of the examples will try to stay in sync with changes in the outside world. To what extent this will succeed is a future promise, but by joining in at early stage, you express the trust that this will happen. As a reward for this trust you get all future content for the current price. This course is the twin of Processing for Designers course. Much of text is the same, as the structure of the Processing and Python is very similar. Also the code examples are very much alike, except that they are adapted to the syntax of each language. And in the advanced part of the courses the examples start to drift apart, because the available functions and libraries is different. You can decide to go through both courses if you want to learn the differences. But if you already have a preference or you made a choice, then following only one of the two courses may be sufficient as a start. If you are starting fresh on programming, the choice can be based on the expertise that is available in your environment, that is a very practical reason. You choice also be based on the difference in flavor between the languages. In preparation of deepening in each of there languages here is a brief summary about their characteristics. Processing is based on Java, an industrial strength programming language, where the type of objects needs to be specified at the start of a program. Python has a much more free usage of types, which makes it good for “sketchy” programming, but it is less reliable in circumstances where the prediction of flawless execution is important. But in reverse, this makes Python much more flexible in the storage of information. Especially the mixing of data type and the storage in the standard dictionary type, allow Python to build data structures that are very hard to achieve in Processing. The origin of Processing is more in the processing of images, – focussed on pixels and interaction – than Python. Python can for instance be found inside web servers and as scripting language in desktop applications such as FontLab and RoboFont. In general Processing programs are more linear, smaller and dedicated to a specific task, where Python programs tend to be part of larger systems. In that respect Python should be more compared on the level of Java, the language that Processing is built on top of. Another difference is the amount and type of available libraries of code is another important factor. There a some minor differences in the syntax of the two languages – minor, but for some people they are really annoying, being accustomed to one kind of notation, such as the use of curly brackets to indicate the start and end of blocks of code in Processing (and Java) and the way Python detects the start and end of a block: entirely by the amount indent of a set of code line. In this course the differences between Processing and Python will be mentioned if that is really important, but this course will mainly focus on the use of Processing in the design practice. There are three other important object oriented programming language, who’s structure and syntax are similar to Processing and Python: JavaScript (not to be confused with Java, although the name would suggest the opposite), Ruby (similar to Python, but with a different origin) and Objective-C (the language by Apple to create iPhone and iPad apps). These language are similar, but also so different that for this course we’ll ignore them in order not to confuse different syntaxes. However keep in mind that when you learn one of them well, switching to another language takes much less time, as you already understand how the programming patterns work. In that case it is more a matter of getting accustomed to the difference in syntax and the variation in available libraries. Learning a new language – any language – can be hard. In the beginning, when learning a spoken language, none of the sounds you hear make sense at all. It is then hard to imagine that these incredible noises will ever become something that you understand. And producing the noises, speaking the language in a way that others can understand, seems even harder, a world out of reach. But as designer you have encountered such problems before. You have the experience that there are always parallels between every design project. A typical project starts with the pile of garbage that your customer puts on your desk, in the hope that you can convert it into a structured design, as by magic. At first glance everything seems like chaos. And then, as with every project, no matter how complicated it seems at first glance, there is a moment of surprise. When you dive into it, spending a period of continuous time without Twitter, Facebook or Phone, taking some rest to make your eyes adjust to the new circumstances, you start to see patterns that were invisible before. And then the patterns appear to be connected, and before you know it, you start to understand the bigger picture. You recognize the larger pieces. And that makes the next steps go faster. And then faster again. It still may take a while, but at some point you find yourself at a level were you can explain to others. Learning is design and design is learning. The main problem with programming is identical to acquiring the skills for any new language: words and grammar are essential, but when there is no obvious reason to learn them, when there is no real problem to solve with that practice, it is a drag. Drilling lists of nouns and verbs that you may never need. Learning to speak and understand a language after being dropped in a foreign city, instead, is very effective as a start. To survive, you need to buy your food and find your way in the underground. That is all good for the essential exchange of information, learning the local language. There is no escape. You have to. On the other hand, this approach can take quite some time to get you on a professional level of conversation. Without proper education it is hard to understand the structure of the grammar, especially if it is very different from your native language. The best strategy is to do both at the same time. Live in an environment where you need the language to survive and meanwhile being educated about the spelling and grammar of the language. The aim of this course is to create that foreign city for you. Little background theory and just the right amount of grammar. And only the details that you need to get a certain task done. Building slowly, until you are at a point that you can write your first poem. If that is all you need, then you’ll have a set of nice small applications, doing the dull production work for you. Which leaves more time for your existing design process. And if you think that this is really an interesting area, and that there are lines of code that you can improve by yourself to solve some specific problems, then you are free to alter them. To experiment. You can write your own little stories is this new language. And who knows, maybe you even can be seduced to appreciate that programming with objects, and Python in particular, actually is a design process: what you make would never exist if you didn’t do it. And every time you do it, the result gets better. If you apply that definition of design onto your own creative work, doesn’t that sound familiar? An important issue about programming in relation to your design process is that the emphasis totally changes. Where in traditional design, much effort is in the actual creation of material for a presentation. Drawing manually is a slow process, no matter if that is done on paper or in programs such as PhotoShop, InDesign or AutoCad. For the repeating components of a drawing every iteration will reduce the amount of design decisions to be taken. Every literal copy requires less design thinking than when you make adjustments or draw each component from scratch. When drawn on paper, this is a lot of work. But even using digital applications, duplicating through copy-paste will create a series of identical components. That is a fast method. But when, at a certain point in the design process, the original changes, these manual copy operations needs to be done again. In most cases copy-paste forgets about the relation between the source and the copy. There is no reference maintained. Yet, it is impossible to skip these steps, otherwise the presentation of the design looks very unfinished. So, manual work – as much value as it has for generating new ideas and acquiring the skills – forces a design process to be linear rather that cyclic. Once a lot of manual drawing has been done, it is hard to throw it all away and start over, no matter if new insights would suggest that to be a better option. The main advantage of a fully manual process, is that every decision can be taken without the need to define rules or algorithms. That makes it totally flexible. But also into something that cannot be repeated. Programming is the opposite. Instead of putting all the effort in walking through a linear line of decisions, with programming almost all design decisions are taken during the development of the algorithms. Generating the final output is nothing more than the push of a button. The combination of the program and a set of parameters generates a specific state of output. Changing one or more of the parameters can radically modify the appearance of the output, very much dependent on the way the program is conceived. The design decisions are mostly focussed on which parameters are needed, what the bandwidth of their values is and how they should interact when interpreted by the program. The disadvantage of this method is that it restricts to the type of designs that can be described in an algorithm. If the algorithm gets more complex than the actual drawing, or if it takes more time to develop it than making the drawing manually, then writing the program makes no sense. But if it is possible to describe the output as a set of rules, then it is very easy to create hundreds of different versions with the same program, just by adjusting the values of the parameters. It needs design skill to decide wether a design problem must be solved manually or by developing algorithms. The bigger the design problem, the more divers the number of possible solution, the less likely it is to write a program that does the job. But if the design problem can be split into smaller parts, then it become more realistic that a program van be written to make the design decision. Imagine the difficulty of writing a program to “Design a new magazine”. It not likely to do that, unless a lot of decision have been made by the designer or programmer, before the programming can start. But when the problem is split into smaller pieces, it is very realistic to write a program that will decides on the best layout, with a given amount of content, text and images. This course is about programming in Python, but it is also about design. In more that one way. We will look into the design aspects of programming, such as the creation of classes and giving the right names to objects. But the process of programming is also very similar – identical? – to design, where you do things over and over again, and then the next time it gets better. And finally, in the second half of the course, we’ll dive into the more sophisticated kinds of programming: how can you make programs that actually take design decisions. Don’t worry, robots don’t take over the world – yet – , you still have to write these programs yourself. But meanwhile it is very possible to write programs that simulate the design process. Just by adding some simple decision algorithms. This course will bring you to that level, step by step. Let’s start The Python Application Python is a object oriented programming language. What that means will be explained during this course. The language was designed by Guido van Rossum, starting as a university graduation project, he has been working on improving the language and the program ever since. He has been given the title Benevolent Dictator for Life by the Python community. Python is roughly two things: it is a standardized syntax, the grammar of the language, that describes how programs should be written in order to be recognized without errors. A Python program therefor is nothing more than a file with text. Not just any kind of text, the format should fit the Python grammar, but nevertheless it is just a text file. The other Python is an application, specifically made for the platform it is running on, that understands, interprets the syntax – so it can detect mistakes in the grammar – and then it can execute the found instructions. In the current major operating systems such as Windows and Mac OS, the Python interpreter is standard installed. The advantage of this layered approach, the Python application is made specifically for the platform it is running on, is that in principle the Python code itself is independent of the type of Operating System. There are different Python versions – there is a 2.7 version as well as the new 3.x version – but from our current point of view in the course the differences can be ignored. The default Python interpreter has no interface on the desktop of Windows or Mac OS. You need to start the terminal application in order to reach communicate with the application. As this course is intended for designers, I take the liberty to focus on the usage on iOS, but that does not mean that Windows could not follow most of the course. It’s just that the platform we will be using to demonstrate is iOS based. For Windows users some alternatives will be mentioned, but for practical reasons they won’t be developed as demo here. First let’s do some nerdy stuff. Just to invite you to the core of Python, so you know where it is and how it works. Also this will make you appreciate better when we’ll use the more interactive application DrawBot for the development of the code in this course. Open your Applications folder. Then search for the Utilities folder and open it. Then start the application Terminal. Then you should see this. Type “python” (all in lowercase) and hit the enter key. This will make the iOS search for the Python application which is hidden even deeper in your system than the Terminal application is. If all goes well you should see something similar to this. The text is generated by Python, showing which version your default Python application is and that the start when all right. The three >>> larger-than characters indicate that the Python interpreter is now waiting for your input. If you don’t see that, there is something wrong with the Python interpreter on your system. It is very hard to solve that from my position here now, but the best chance you have it to re-install the iOS, or update to the latest version, if your haven’t done that right now. Just to show that this really is Python you are talking to right now, type “print 7 * 7” and hit the Enter key, to show that Python knows how to multiply. It will tell you then that the answer is 49. Later in the course we will come back here, because knowing how to operate Python from the Terminal makes some very powerful functions available for you as designer. For instance in manipulating large amount of files or performing time consuming tasks, that otherwise would involve a lot of manual clicking and dragging. For now you should download DrawBot. That is a small environment, made by Just van Rossum, brother of Guido, for educational use. It is using the same Python interpreter as you saw working in the Terminal, but now there is a more convenient window interface wrapped around it. You can download the DrawBot application from drawbot.com Also there is a brief set of instructions and examples, but all of that will be covered in this course too. Basic coding Once you have installed the DrawBot application, open it by a double clicking the icon. Then you see this window with three frames, each with a different function. The frame on the top right is the area where you will type your program. The frame at the bottom right is where the Python will show the text result of a program that your run. Do the same thing again as you did in the Terminal. Type “print 7 * 7”. Instead of hitting the enter key, now choose Run from the Python menu, or type cmd-R. The Python interpreter in DrawBot now shows the same answer in the frame at the bottom: 49. You can change one of the values and run the program again, for instance this: “print 7 * 7 * 7”. Now the new answer is visible at the bottom. Every time you change something to the program you need to type cmd-R to make it run again. You will do this a lot during this course, each time to check on the code of the Python program, while you are writing it. You can adjust the font type and size of the code editor in the Font menu. DrawBot was initially made by Just for educational purposes. To use the program in a presentation it is of useful to adjust the size of the type. The frame on the left is the area where DrawBot can do the drawing. This is one of the main advantages in using this application compared to the Terminal, because there is no area to draw there. Add a second line of code in the Python editor frame that says “rect(10, 10, 100, 100)” and run new version of the program by hitting cmd-R again. Now the answer of the multiplication is still visible again, but also there is a new black square at the bottom left of the drawing frame. As you may suspect, the square is positioned at 10 pixels from the left and 10 pixels from the bottom. And the width and height of the square is 100 pixels. These values correspond with the parameters you have put between the brackets. The first 10 is for the x-value, the distance from the left boundary of the drawing frame. The second 10 is for the y-value of the bottom boundary of the drawing frame. Note here that the y-value goes from bottom up, which is the mathematical description of the y-axis. This is different from typography and page layout, where the text grows from the top of the page downwards. This is a difference in orientation between a mathematical coordinate system and a the coordinate system of a page. One can easily be calculated into the other, which we will do later in the course. For now, as long as we are not doing anything with layouts, we’ll use the standard mathematical orientation, where the y-axis point upward. You can see the square change. Change the width of 100 to 200 and run the program again. Now the square is replace by a rectangle of 200 pixels wide and 100 pixels high. Duplicate the code line that draws the rectangle, so a second rectangle will be drawn. We have to change the position, or else the rectangles are drawn over each other. The second one is invisible then. Now let’s have a little thought about the position of the second rectangle. If we make the x position a bit larger, then the rectangles still overlap, showing as one wider rectangle. If we want to draw them next to each other, we also can make Python do the calculation. So if the x position is 10+200+10 (10 for the left margin, 200 for the width of the first rectangle and 10 for the gutter between the rectangles) then the second rectangle shows next to the first one. As if they indicate the columns of a text. If we duplicate the two lines into 4, then we can adjust the vertical position of the third and fourth rectangle in the same way. The y position will then be 10+100+10 (10 for the bottom margin, 100 for the height of the first two rectangles and 10 for the gutter between the old 2 and the new 2 rectangles). Now the rectangles show with a fixed position of 10 pixels between them. Note that separate instructions always need to start on a new line, otherwise Python cannot easily see the separation between two instruction. Different from programming languages such as Java and JavaScript, where the semicolumn “;” is used as separator, Python is using the line break as separator. Imagine that this could be the grid of a page, especially if we add these two color lines on top of our little program. print 7 * 7890 stroke(0.5) fill(None) rect(10, 10, 200, 100) rect(10+200+10, 10, 200, 100) rect(10, 10+100+10, 200, 100) rect(10+200+10, 10+100+10, 200, 100) The “stroke” tells the Python interpreter to set the color of the outline to a middle gray. And the second line “fill” tells the Python interpreter not to fill the rectangles with the black color we had before. It is important that the None has an initial capital, it is one of the reserved words in the Python language, indicating the None object. There is a difference between 0 (which would indicate black) and None (which indicates Nothing). What you can see in this stage is that we need a lot of code lines like these, to draw all the rectangles of a grid or a page. That not a problem at all for the Processing interpreter, but it is a problem for us. It becomes obvious, that copy-paste is an easy method in a program to generate more information and more elements in a drawing, but the tremendous disadvantage is that with every copy-paste the relation with the source is lost. So we get a lot of code, but there is not structure between the code line. There is no knowledge about the relation left. So, for instance, if we would like to change the size of the columns, it would need a lot of manual work to adjust all the widths of the rectangles and also change the position of the rectangles that are next to the changed ones. This manual work is the direct result from our copy-paste action. The rectangles have no knowledge about their neighbors. If something changes to size or position, is does not have any consequence for the other elements on our page. So we need a more efficient way, more using the strength of a program, instead of making a flat list of drawing instructions. This difference “copy-paste” versus “using an algorithm” is one of the most important issues to learn about programming. In this course about how to design your design thinking it is a repeating issue in particular. That principle will be mentioned often. In order to program algorithms, we need to look deeper into the Processing language, to gather some basic understanding on the different functions that are available. All the code mentioned in this course is available as supplementary source files. So, you could download the files and copy-paste the examples. For efficiency reasons that is a good option later in this course, because you also will need some predefined code libraries. But for now I advice you to type all the code yourself. It is the best way to learn the language. Not just reading but also to do the writing. There are many similarities with writing the code and drawing and sketching in your other design projects. The aim of this course is to make you experience the similarities and also show you techniques to think and sketch and rethink about algorithms in your Moleskine sketchbook. Forget about the drawing part for now. Let’s start looking at some basic Python coding, before we continue. You already saw the behavior of one of the standard types of objects in Python, the integer. An integer is a whole number, no fraction, that can have a positive or negative value. Also the zero is considered to be an integer. What we did so far is multiplying two integer values 7 where the result was another integer with the value 49. Exactly what you expected to happen. In Python that is often the case. The language is designed to be intuitive. If you expect some behavior of the naming of a function, try that one first. It is likely that the designers of Python thought along the same path, and implemented the function exactly in the same way as you expect. Often this is true, so trusting your intuition will increase your development speed and reduces the amount of time spending on looking things up in the manual – either as book or online. Play a bit by changing the values of the multiplication. The very convenient thing about Python is that it tries to understand what you want to do. Unlike languages as Java, where for instance you have to describe the type of value you want to work with, Python assumes and guesses a lot. For heavy duty industrial processes this may lead to unpleasant and unpredictable results sometimes, but for the usage in our design environment that is not a problem. It is a feature, an advantage. In our case the sketchy nature of Python programs is very complementary to the sketching you do as a designer. You don’t know all the questions and answers up front. While you develop the program, the specifications of the values that you use should transform accordingly. We need to go through some boring basic stuff. I promise to keep it brief, but there are some conventions that you need to understand as the basic grammar of this new language. As you already guessed the other mathematical operations on integer numbers work as well. Running the code 7 + 7 will has 14 as result, 7 - 7 shows zero and 7 / 7 shows 1. Play a bit more with calculations that have several operations in on line. For instance try “print 7 + 7 * 5” and notice that the answer is 42. It is the answer to everything, according to the Hitchhikers Guide to the Galaxy, by Douglas Adams. Note that the answer is not 70, which would have been the result of print 14 * 5. The multiplication is preferred above the addition, following the standard mathematical rules. Multiplications and division are grouped together and calculated first, and then the result is added or subtracted. This is called the distributive property of these operations. If you want the addition to take place first, use round brackets around that operation. Thus “print (7 + 7) * 5 actually has the output of 70. Note that you have to add the “print” instruction in front of the calculation line to indicate to the Python interpreter what to do with the result of the calculation. If you omit the “print” instruction, that the calculation is still executed in a valid way, but the result is ignored. It does not show up in the output frame. You may notice that the word “print” is colored, by the Python editor of DrawBot. The color is a reminder that this word – identifiers as names are called in a programming environment – is reserved by the Python language definition. It cannot be used for anything else. That applies for a number of other words that are part of the core definition of Python such as for, in, def and class. The reserved words are exactly matching. Any alteration to them, such as one or more capitals, adding and removing characters make them into unique names again, not being part of the core syntax of Python. If you want to use the word class (for instance because you are writing a program that generates HTML code for websites) then class could be written as cls or class_. These names are not used in the Python language). Normally you don’t want to show the result of every calculation. In most cases you want to use the result again. In that case we will store the resulting value under a name. This is how works. Replace the line by “a = 7 + 7 * 5” and run the program. Nothing is showing in the output, but the result of the calculation is now stored as an integer – a whole number – object with the name “a”. That name is something I just made up. It could be anything else, as long as the name is build from letters, figures and underscores, in any combination. It is a well recognized convention in Python programs that the name of plain objects, such as the “a” starts with a lower case. So the name “myHitchHickersGuide” would have worked in exactly the same way. Now we have stored the result of the calculation as object – also called instance), we can show it. Add the line “print a” to your program and run it again. You will see the 42 show up in the output frame. Apparently that value was the object with the name “a”. Unlike other programming languages, Python integers can have any size. The limit is defined by the available memory (and calculation speed) of your computer. So if you multiple 2 really really large numbers you may notice that the answer takes a little bit longer to calculate and to print, but it still does it. Try, for instance to multiply two very large numbers: print 123456789012345678901234567890123456789012345678901234567890123456789012 345678901234567890123456789012345678901234567890123456789012345678901234 567890123456789012345678901234567890123456789012345678901234567890123456 789012345678901234567890123456789012345678901234567890123456789012345678 901234567890123456789012345678901234567890123456789012345678901234567890 123456789012345678901234567890123456789012345678901234567890123456789012 345678901234567890123456789012345678901234567890123456789012345678901234 567890123456789012345678901234567890 * 123456789012345678901234567890123456789012345678901234567890123456789012 345678901234567890123456789012345678901234567890123456789012345678901234 567890123456789012345678901234567890123456789012345678901234567890123456 789012345678901234567890123456789012345678901234567890123456789012345678 901234567890123456789012345678901234567890123456789012345678901234567890 123456789012345678901234567890123456789012345678901234567890123456789012 345678901234567890123456789012345678901234567890123456789012345678901234 567890123456789012345678901234567890 Are you still here? Note that you can stop this video any time and play with the numbers by changing the code lines, to see what happens. Try to predict and understand what happens. If you see a red remark in the bottom part of the editor window, then you made an error in your code. The Python interpreter is checking your code against the standard Python grammar. If it finds something wrong it will show the error message, guessing what might be the problem and showing the line number and a suggestion what the error likely is. Note that this is not alway accurate. If there is a major mistake in the syntax, by definition Python does not understands what you mean. So is also cannot know what it is, that you did wrong. But in general the interpreter is capable of doing a fairly good guess. Let’s continue with the exploration of the standard type of objects in Python. So far we used integers. Then there is another type of number, called float. This type contains the numbers that are not integers but fractional values, such as 3.14. If you multiply a float with a float, of course the result is a float again, such as in “print 3.14 * 2.71”. This shows up as 8.5094 in the output frame. Also multiplying a float with an integer will result in a float number. Another important type of objects in Python is the string. That is not the name for a specific type of under ware, but it is the collection of a sequence of characters. That is the way chunks of text can be stored. The syntax of a string is to start and end with a single quote or a double quote. It doesn’t really matter which one you use, as long and the start and end character is the same. Type “print 'Hello world'” and run the program again. Now the output frame contains the content of the string, as you expected. As said before, Python is an intuitive program. This means that functionality is implemented in such a way that it behave as you expect. For instance the addition of two string creates a new string. See for instance “print 'Hello ' + 'world'”. Now the two strings are glued together into one single string and then printed, resulting in the same output as the previous version. Don’t forget to add the space at the end of the string, or else the two words get vacuumed. Similarly a string can be multiplied by an integer number. This results in a string that has that amount of the same string glued together. “print 'Hello ' * 10” greets you like a crowd. There are some other issues to strings, such as making them work with unicode – you need this for other languages than the Latin script or when using accent characters – but that will be addressed later in this course. Plain strings are sufficient for now. If you want to leave notes in the code for yourself, then use the # hash symbol. It is part of the Python syntax to ignore all the text after the hash symbol, until the end of the line. This way you easily can add comments at the end of every line of code, as notes to yourself about what actually happens here. So we let’s add some to the previous lines we did so far. The art of adding good comments is like developing conversation techniques. If you make a lot of noise without saying much, there is the tendency that people won’t listen. And if the information is so short, that it starts to be an exercise of decryption, then the comments are of little use. Writing the comments that are just right, needs practice of balance. That is a micro design problem for every line of code that you write. Comments are like a one way conversation with who you a one year from now. You have to imagine who you are then. What your knowledge is and your willingness to study the code you are writing now, to understand what it does. This clever idea you got today, may not be clear at all, when it is seen in the context of the world a couple of months from now. And that is even more true if someone else has to read your code at that time, without the memory of writing it at all. Then there is another important basic object type in Python: the list. A list is an object that contains an indexed set of other objects. That can be any number of any type of object in any order. So for instance “myList = [0,9,1,8,2,7,3,6,4,5]” is a list of integers, in the specified order. Notice that in my definition there are no spaces between the commas and the numbers. The square brackets are the symbols for Python to recognize that the everything in between should be interpreted as being part of the list. Now if we print the list object in the following line of code “print myList” it will show with spaces behind the commas. This proofs that the list is constructed as an object and the it is printed it gets transformed into a string again, independent of my original description. Because the list is a standard object type in Python that can contain all other Python objects, it can also contain other lists. This construction is called recursion, word that will often be used in this course to indicate when definitions are described in themselves. A list inside a list will show, for instance as “myList = [1,3,5,6,['another list', 100],7,8,9]” where one of the elements of “myList” now is “['another list', 100]”, besides the range of integers. Another Python type that is closely related to the list is the tuple. Instead of square brackets it is defined by round brackets, as in “myTuple = (1,3,5,8)”. Lists and tuples behave almost identical. The subtle differences will be addresses later in the course. For now you can consider them to be equal. Lists and tuples are an efficient way to group a number of values together, especially if their behavior is similar and if we don’t need to select one particular value from the pack. Since a list is a sequential creature, it becomes inefficient to search specific information in huge lists, because the program needs to run through the entire list, from start to end, in order to find that value. Like you need the meaning of a certain word and all you have is a stack of all the English words with their meaning, not ordered in alphabetical order. Since the word you are looking for can be anywhere in the list, the only thing you can do is to start with the first element and compare, then the second and compare, then the third, etc. If you are lucky then the word you are looking for is in the beginning of the list. But fat chance there are also words that are at the end of the list, and then your have to go all the way through, one by one, to find that you are looking for. For a very small list this is not a problem, but for huge lists this is not an efficient way to search. The best way to use list is roughly in 2 types of operations. The first is to use the list a source for using the values in a loop. It is possible to run through the entire list to perform the same operation on all element. Type the following 2 lines of code. for n in [2,3,4,5,6]: print 'Value is', n Make sure to indent the second line and add the column character and the end of the first line. The first line tells the Python interpreter to run through the list of [2,3,4,5,6], where for each cycle a new value is taken from the list and put into the object named “n”. For as many values as there are in the list, the block below is executed. Different from programming languages such as Java and Javascript a block is defined as everything between { and }. In the Python syntax a block is defined by all the lines that have an identical indent. So in this case the second line is executed for every value of the list where the value is available in “n”, which is then printed by the second line. Executing these two lines show the values of the list, each on a new line. Value is 2 Value is 3 Value is 4 Value is 5 Value is 6 The other main usage of lists is as source to retrieve values by their index in the list. To see how that works, execute the following lines: myList = [2,3,4,5,6] print myList[1] The second lines instructs the Python interpreter to get the element from myList with the index “1”. This results in “3”. You may have expected to see the first element of the list, which is “2”, but the index values for a list start with “0” instead of “1”. So to get the first element from myList the following code should be used “myList[0]”. Also it is possible to get more values than just one. This is called slicing. A slice is a list that is cut from another – larger – list. The syntax of getting the second to fourth value from the list is this “myList[1:4]” which results in the list “[3, 4, 5]”. It is possible to add lists. That leads to the introduction of another very important basic object type in Python: the dictionary. Where in a list the elements have a certain fixed order (although that may not be alphabetic), in a dictionary the elements have no order at all. The elements are not retrieved by their index position. The values are retrieved by the same key as they were stored in the dictionary. Let’s have a look at some more example lines of code. Now we have seen the basic types of Python, let’s do some visual examples, to show how they can be used as design tools. Design methods So far we just looked at a sequence of code lines. Programs that work in a linear way, have can only have limited functionality and complexity. The disadvantage of programming this way is that it is impossible to reuse the code for other purposes, without changing the code. In Python it is possible to isolate chunks of code and give them a name. Such a chunk is called a method. The name of a method is called to execute it. Let’s make an example now that reflects objects in reality. -------------------------------------------------------------------------- Design of classes Classes are the most important aspects in an object oriented programming language, such as Python. Where a method isolates a piece of code and makes it available under a name, in a class that concept is even more strongly defined. A class describes the behavior of a set of objects, independent entities of code. In Python terms the objects are called instances. In detail objects can different, but their overall behavior is identical, defined by the class that made them. Imagine a stack of randomly selected books. They are likely to be different in size, color, number of pages, binding technique, cover and material. Yet their overall behavior is expected to be the similar. For books that are based on the Latin script, it is very likely that they will open from right to left, that the uneven page numbers on right pages, that the cover contains the title, that the back of the book shows the title vertical and that most books will fit in a pocket or bag, etc. Defining this stack of objects to be part of the class “Book” means that we can predict their overall behavior. The differences between the individual books are then called the attributes of the objects, such as their title. The class of Cars is another great metaphor for explaining how object programming works. Cars are good example products to illustrate how design works. They all have similar functionality – driving on a highway, using an internal power source – anyone knows more or less how they work. They include highly innovative technology. Industrial products. They are fashionable. They are complicated projects to design, bound to many rules. They are consumer products. They are competitive in pricing and everyone has an opinion about them. And as useful as they are as metaphor in design education, they also are very illustrative as example in our introductory programming exercises. Let’s build a car factory. class CarFactory: The reserved word class – you can see that the Python editor understands, so it automatically adds the color to the word – indicates to the Python interpreter that we are defining a new type of objects, the CarFactory. The name of a class always starts with a capital. That is the convention in the Python language. The names of instances – objects – always start with a lower case. That fact that there is an exception to this – because classes themselves are also objects – is beyond the scope of the course at this point. So I won’t mention that. Oh, I just did. The best way to interpret the class of a CarFactory is to see it’s behavior as a factory of cars. A class knows how to create instances – objects – with a defined type of behavior. In order to define the CarFactory class then, we have to think about what kind behavior a car should have. In design term this equals the description of the list of go-no go parameters. A pan should not melt on a stove. A TV should use 220 Volts or 110 Volts, depending on its location. And a car should be able to drive. So let’s add that for a start. class CarFactory: def drive(self): print “I drive” The indented def indicates that we define a method in the class CarFactory. Using this method, an instance is able to perform a certain defined task. The word following the def is the name of the method. The convention is that method names start with a lower case. And as they have the role of identifiers, they should only consist of letters, figures and underscores. Ignore the brackets with the self for now, we’ll come back to that later. The definition line ends with a column to indicate to the Python interpreter that everything following from here – as long as there is an additional indentation – is part of the method definition. Then we add a single line for now, that defines the metaphor of the driving car. Note that we are not yet driving in this stage. We just define what a car does when it is instructed to do so. It is a plan for action. Not the action itself. Methods as part of a class definition must be seen as the blueprints of a car inside the CarFactory. It’s not the car itself, it is the specification – the blue print – of a car. Now let’s make a car instance, a real object. This is done by calling the class as a function – that is what the open and close brackets do. class CarFactory: def drive(self): print “I drive” mycar = CarFactory() Here the pair of brackets instructs the CarFactory to product a car with default specifications. The result is then stored as object with the name “mycar”. That is an arbitrary name. The initial “my” is often used in demos to indicate that this name is a free choice by the programmer, not dictated by the syntax of the programming language. So we have a new car, sitting there, doing nothing. Unless we tell it do something. In the convention of most object oriented programming languages, the instructions to an object are done by adding a period to the object name and then adding the name of the method to be performed. We already defined the blueprint in the CarFactory for this. The method name is drive, so the car is supposed to handled that request. class CarFactory: def drive(self): print “I drive” mycar = CarFactory() mycar.drive Then nothing happens. The reason for that is that we instructed mycar to select the method drive, but we never told the car to actually do it. Again we need the brackets to make it come alive and perform the requested task. class CarFactory: def drive(self): print “I drive” mycar = CarFactory() mycar.drive() Now the result in the output frame shows “I drive”. We had no influence on the actual behavior, once we have set it in motion. We told the car to drive, but not how to do it. That knowledge is inside the car, created as instrinsic functionality by the CarFactory. This is a smallest construction to show how data hiding works. Instances – objects – contain knowledge that the user of the object is not supposed to know in detail. It is invisible. Even if you do understand everything, still you don’t want to be bothered with all the details all the time. When you are driving a car, you need to concentrate on the traffic around you. You don’t want to pay much attention to the internal functioning of the car. Operating the interface as steering wheel, break and accelerator is all you need. Not the knowledge what mechanical structure the steering wheel connects to the front wheels. Or how the gas peddle is connected to the combustion engine. That functionality is implemented in a totally different way in different cars. The fact that you can drive in any car is because the interface, the position of the peddle, it’s size and it’s is required pressure, is standardized. It fits your expectation and the physical measures of your body. class CarFactory: def drive(self): print “I drive” mycar = CarFactory() mycar.drive() At this point I alway draw a commented line between the definition of the CarFactory and the creation of the car, to indicate that the top of the code refers to the standardized description of the factory that eventually could be part of a reusable library, and the bottom code, which actually is part of our application. class CarFactory: def drive(self): print “I drive” # ------------------------------------------------ mycar = CarFactory() mycar.drive() Again you see that the # hash sign in a line of code, makes all the following text into a comment. The DrawBot editor recognizes this and shows that comment as gray, for our convenience. The coloring in the program is just intended as feedback for the programmer. The color has no function whatsoever for running the code. The coloring is done by the editor, which has no real binding with the actual Python interpreter that executes the code. You should feel free to play around with the code all the time. And that will increasingly be the case during this course, when you are asked to do some exercises. However, take care to check every detail of the code with the examples. Some details don’t matter, such as the amount of spaces inside a line of code, but some other details are crucial, such as the indentation level on the left side of a line, because for the Python interpreter that is the way to determine the hierarchy of the blocks of code. In case you see a red error message in the output frame, you made a typing error somewhere. It is best practice to store various versions of your code, anytime you start making changes again to something that worked before. In case your changes go too far out, and cannot be restored into running code anymore, you always can go back to the previous version. To force the showing of the error message as example of how it looks, I remove the last bracket of the mycar.drive( This will cause the error message in red: SyntaxError: invalid syntax It is a good choice at this point to save the program code that you have so far. Cmd-S will show the standard file selection dialog. Create a folder somewhere on your computer were you will store all the sources you create during this course. Choose a telling name, for instance something like “carfactory-o1.py” where you add the extension “.py” to show your computer that this is a Python source code file. If you make new or alternative versions of the source you can increment the number (using the Save as…) menu option, so the file will not overwrite the previous version. If you expect that the number of version will exceed 9 (which it often does), then it is a good idea to add an trailing zero to the number, so the files will be sorted in the right order when you view them in a Finder window. With larger applications the class description is often not part of the program that you are writing. It is stored in separate files or in a library. This allows much easier re-usage of the code, than adding everything together in a single file. But for clarity in our example program, it is easier to put them in a single file. The line pretends to show the separation. The next thing to add it some control on the speed of the car. With the current model, all we can do right now is just ordering it to drive, but we cannot request a speed, and there is no feed back about the actual speed, which may be different from what the request is. Let’s change the specification of the factory for the behavior of this car model. In most programming languages the call of a method of function allows the passing of values. These are located between the brackets. You can best visualize the arguments as buttons and handles on the dashboard of the car. So instead of driving on and off, we want to be able to submit the speed as argument in the drive method. That would be something like mycar.drive(50). But if we now run the program, there is an error. 
Traceback (most recent call last): File "[untitled]", line 6, in ? TypeError: drive() takes exactly 1 argument (2 given) With this error message Python tries to tell that there is the method is called with one more argument that what it expected. So what happens is that we are trying to use the drive method in a different way than what is defined in this model of the car. Like you added a button on the dashboard of a real car, but forgot to add the wire from the button to the engine. In order to make the speed argument work, the factory needs to be changed, so it will add this new functionality to the car model. class CarFactory: def drive(self, speed): print "I drive", speed, "miles per hour." # ------------------------------------------------ mycar = CarFactory() mycar.drive(50) You may notice now that the drive method in the factory got an extra argument with the name “speed” and that the value of the speed is added to the output string. The result is then that the car will show its speed when ordered to drive in a specific amount. We can easily reuse the drive method now with different speeds. The car responds accordingly. Also notice the subtle issue that factory is not supposed to know about actual speeds of a car. It just has to supply the functionality to drive any speed. class CarFactory: def drive(self, speed): print "I drive", speed, "miles per hour." # --------------------------------------- mycar = CarFactory() mycar.drive(50) mycar.drive(40) mycar.drive(35) Here mycar is driving in different speeds, which could be the sequence of speeds from start to destination. The car responds with the appropriate lines: I drive 50 miles per hour. I drive 40 miles per hour. I drive 35 miles per hour. However there is a flaw in the current functional description of the car. Because the drive method just copies the speed – any speed – that we put into the method, the car will not have any limit in the speed it can drive. mycar.drive(-50) mycar.drive(100000000) will make the car respond with I drive -50 miles per hour. I drive 100000000 miles per hour. In reality this is impossible. Even when you order a car to drive faster that its maximum capacity, it still won’t drive faster than that. The physical limitation will forbid that. So, to make the behavior of the car more realistic, we can build in some limitations in the method. First we want to make sure that the car is not allowed to drive with a negative speed and there is a maximum. In Python there are two standard functions for that. Add the following line for testing: print min(10,100), max(20,200) This gives the result line: 10 200. The 10 comes from the minimum value of the pair 10 and 100. And the 200 comes from the maximum value of the pair 20 and 200. We can use these functions to limit the speed in the drive method of the car. class CarFactory: def drive(self, speed): speed = max(0, speed) speed = min(100, speed) print "I drive", speed, "miles per hour." Two lines were added. The first line takes the maximum of 0 and the current value of speed and puts the result back into the speed argument. Whatever the original value of speed was, it is overwritten with the adjusted value. Unless there is a reason to keep the original value, we are not just interested in the actual speed that this car can drive. So this line takes care about any instruction that was below zero. A car can not have a negative speed, so now it is according to reality. The second line does the same thing in the other direction. If the car has technically a maximum speed of 100 miles per hour, then the max( ) conversion of the speed will limit the value. mycar.drive(-50) mycar.drive(100000000) now will make the car respond with I drive 0 miles per hour. I drive 100 miles per hour. What you see here is that the main task of writing the program is not really managing the code or applying the right syntax. We have to do that of course, just as much as a written story should fit the syntax of the language it is written in. But the main task is to create the story, to compose the information. Designing the behavior of the car is what we really are doing here. Identical to any design process of a product of publication or website. Let’s think about some more functions that this car design should be able to perform. If we can set the car in motion with the drive method, there should be a break method too, to make the car stop. So we add that to the description of the behavior of the car in the CarFactory class. class CarFactory: def drive(self, speed): speed = max(0, speed) speed = min(100, speed) print "I drive", speed, "miles per hour." def stop(self): print "I stop." mycar = CarFactory() mycar.drive(50) mycar.stop() will now show as I drive 50 miles per hour. I stop. Note how easy it is to add functionality to a class of objects. Just add the method definition to the class, and then all objects of that class increased the functionality according to the new class definition. If we really want to drive in this car, it would be necessary to do some steering too. We want to define the directions. What would be an appropriate interface, to simulate the steering wheel? For now maybe the addition of a turn method. Then the class definition of the CarFactory could be something like class CarFactory: def drive(self, speed): speed = max(0, speed) speed = min(100, speed) print "I drive", speed, "miles per hour." def stop(self): print "I stop" def turn(self, direction): print "I turn", direction + '.' mycar = CarFactory() mycar.drive(50) mycar.turn("left") mycar.turn("right") mycar.turn("around") mycar.turn("30 degrees to the left") mycar.turn("right at the next cross road") mycar.stop() And the result of the execution is I drive 50 miles per hour. I turn left. I turn right. I turn around. I turn 30 degrees to the left. I turn right at the next cross road. I stop. So far, out car is pretty generic. We can drive around with it, but there is nothing about it’s appearance or other intrinsic values of the car. None of the driving and turning is part of the car itself and once it ends, the car does not remembers anything about it. Now let’s some car characteristics. One of the most obvious attributes is the color. If we stay with the physical relation with the behavior of cars, then the changing the color is not something the user will do. It is an attribute that needs to be defined in the production stage. So it should be specified to the CarFactory, when the car is ordered. This would be the way to specify it: mycar = CarFactory('red') This reflect how this works in reality. Ordering the car should include the specification of the color. However our current factory does not know anything about what to do with this new attribute. In a real factory changing the color of the car during its production would need to create the facilities. Right now we get an error: 
Traceback (most recent call last): File "[untitled]", line 13, in ? TypeError: this constructor takes no arguments This means that the “constructor” – the factory – does not take any parameters for the production of the car. We need to change the description of the CarFactory a little. This is done by adding another method with the weird name __init__. This needs a bit more insight of the internals of Python. If you define a method with a name that starts and ends with a double underscore, that redefines the way an instance works by default. The __init__ method is called at the construction of the car. So if we redefine that, so it understands what the color argument is about, then we can tell the factory which color car to create. class CarFactory: def __init__(self, color): self.color = color Sorry about the confusing double underscores in the name, but that is part of the Python language. This is only one example that you need a lot when defining classes. The trailing underscore has special meaning in the naming of methods and arguments. There are many more like this one that can alter the default behavior of classes, but now that is beyond the scope of this introductory lecture. Now the CarFactory takes the color as an arguments. Let's focus on what the __init__ method does with it. You see two arguments, the self you saw before, as we used it in the drive and turn and stop method definitions. This self is very strict convention to use as first argument in a method. Inside the method it contains the current instance, as it is created by the CarFactory. You best can imagine this as the actual object that is being manufactured, before it is released from the factory. This gives the opportunity to alter the conditions and behavior of the car while it is still in the factory. That is what actually happens here in this line inside the __init__ method: the color argument is taken – whatever color it is – and it is stored in self. So the car remembers its initial color. The color value becomes part of the car. We can test this by adding for instance the method show. def show(self): print 'I am a beautiful', self.color, 'car.' mycar = CarFactory('blue') yourcar = CarFactory('red') Here we created 2 cars at the same time, by the same factory, but with different appearance. We can see that difference by making the cars show themselves. The print line generates the response, while using the self.color to retrieve the actual color of self, once the method show is called. This is the internal behavior, but we only have to define that once, inside the factory. The external behavior is as follows: mycar.show() yourcar.show() will show I am a beautiful blue car. I am a beautiful red car. See how the same show instruction to the car, generates different output. We don’t have to remember the color of the car. They do that for themselves. We just have to ask. This concept is one of the most important aspects of object programming. The behavior of an object is defined only once, in the factory. If the instances are created, they are independent. They know how to respond to requests from the outside world and most of that functionality is hidden inside. We don’t need to know what the car instance is doing to respond to our show request. We just need to remember that we can order the car to show itself, the rest is done by the car instance. That is an obvious difference between programmers. Old-style programmers that work for instance in C, will talk about their that code as “I do this” and “I do that”. But object oriented programmers will say that they instruct the car to show itself, treating the instance as an independent entity, that can be influenced but not be controlled. It is this word twist that is often mistaken in Science Fiction movies, it is often used by people who think to benefit from presenting programming as something magic. Of course we are in control, we just wrote the CarFactory ourselves, there is no magic there. Just as much as there is no magic inside a real car. But when we are on the bottom side of the dashed line, we can use the object without the need to think about its functionality in every details. There would be no brainpower left to check on the traffic around, if all attention goes to the internal functioning of the car engine. The conversion of information into objects with an interface is very much related to how we look at design problems in general. Make the amount of apparent details match the situation. As Henry Ford once said: The Ford is available in any color as long as it is black, indicates that we still miss something in the our ordering procedure. If the color is omitted, we currently get an error. In Python there is the possibility to define defaults to arguments, by adding the default value in the method descriptor. class CarFactory: def __init__(self, color='black'): self.color = color mycar = CarFactory() yourcar = CarFactory('red') will show I am a beautiful black car. I am a beautiful red car. Omitting the color in the factory order, will result in a black car. There are many more aspects of describing the behavior of classes and instances. In this first introduction we skip most of them, in order to keep this lecture relatively simple. Just to get the overall picture. But there is one last issues that needs to be covered. That is called inheritance. So far we only looked at the behavior of the CarFactory, which produces a car instance. But in real car manufacturers have a brand. Besides that you buy a car as a metal box on wheel to get from point A to point B, a car is also a brand. One solution to that is to copy-paste the existing code for the CarFactory and then call the class VolkswagenFactory. It would seem to be a valid solution, since we get all the existing functionality in our new factory, now creating Volkswagens instead of unbranded cars. But there is a major disadvantage to that approach. Any copy-paste action will disconnect the new code from its original source. So any change made later to the original will not reflect in the Volkswagen code. That is okay if there is not remaining binding, but in this case most of the functionality should remain identical. Extending the functionality of the CarFactory with more car function, would be nice to have in the VolkswagenFactory too. In object programming this feature is called inheritance. By inheriting the VolkswagenFactory from the CarFactory, the reference to the original code is maintained. Only the differences between a Volkswagen and the generic Car needs to be defined. In practice this is very little code, only specifying some parameters. The code for the VolkswagenFactory then should be as follows: class CarFactory: def __init__(self, color='black'): self.color = color def drive(self, speed): speed = max(0, speed) speed = min(100, speed) print "I drive", speed, "miles per hour." def stop(self): print "I stop." def turn(self, direction): print "I turn", direction + '.' def show(self): print 'I am a', self.color, 'unbranded car.' class VolkswagenFactory(CarFactory): def show(self): print 'I am a beautiful', self.color, 'Volkswagen.' mycar = CarFactory('red') mycar.show() gives I am a red unbranded car. But if we now create an instance using the VolkswagenFactory with mycar = VolkswagenFactory('red') gives I am a beautiful red Volkswagen. So the Volkswagen and the unbranded car respond to our show instruction, but the outcome it different, depending which factory we used in creating it. The only difference between the VolkswagenFactory and the CarFactory it is inheriting from is the redefinition of the show method. All other code in the CarFactory is used by the VolkswagenFactory too. During this course you will see this happen often. Every time a design problem can be defined, it can be split into a generic part – which we only have to solve once and then put it into a library, available for later reference – and the specific part that is bound the problem we are solving. Similarly we can inherit from the VolkswagenFactory again. class PorscheFactory(VolkswagenFactory): def show(self): print 'I am a very expensive', self.color, 'Porsche.' mycar = PorscheFactory('red') gives I am a very expensive red Porsche. Any change in a later stage to either the CarFactory of VolkswagenFactory class will reflect automatically in the PorscheFactory class, if it matter values or behavior that was not already redefined in the inheritance. There is one last details we’ll add to our metaphor of the car factories, that shows the right kind of distribution of knowledge. It is best practice to separate the functionality as much as practical from clean information. In our example the maximum speed value is defined in the drive method. That is not really a good choice, because now all cars have the same maximum speed, which is not really the case in reality. We could redefine the whole drive method in the Volkswagen class (since they can drive faster than the unbranded car type) and then again in the Porsche class, because then it is faster than a Volkswagen again. But that approach is not a good idea. Besides the redefining of the maximum speed, we also would copy the entire functionality of the drive method, just for this one value. The solution to this is to make the maximum speed into a value that is stored in the car itself. Then the drive method become generic again, and the only thing the inheriting classes need to redefine is the single value of for their specific maximum speed. So the redefinition of the drive method in the CarFactory now becomes: class CarFactory: MAXSPEED = 100 def drive(self, speed): speed = max(0, speed) speed = min(self.MAXSPEED, speed) print "I drive", speed, "miles per hour." As you may notice the value 100 in the drive method was replaced by self.MAXSPEED. That looks like the construction we have before with the self.color as a way to retrieve the color of the car. The difference is that the MAXSPEED is not part of the one car instance (as there may be different colors for each instance). The MAXSPEED is a value comes with the model. In Python this still can be referred to through the self.MAXSPEED construction, as if it really was part of the car, but in fact the value is defined in the class itself. These kind of values are therefor called class variables. It is a layout convention to write class variables all in capitals for readability, but it is not dictated by the Python language. Note that inheriting applies here too. So if an instance will redefine a class variable then that value is taken in preference of the class value. It is good practice to define a default fallback for any of the values that can be redefined by inheriting classes. This way the code never breaks when someone refers to it with an inheriting class. The adjustments can then be made later to control the differences in more detail. Now the only thing we still need to do is to redefine the MAXSPEED on the inheriting classes of the VolkswagenFactory and the PorscheFactory. class VolkwagenFactory(CarFactory): MAXSPEED = 150 class PorscheFactory(VolkswagenFactory): MAXSPEED = 220 Now the information is where it belongs, in the respectively factory definitions, that are responsible for a certain type of car. And the one generic drive method just know how to apply the value of the maximum speed. It is not supposed to know what that value actually is, because it is defined by the class that is inheriting from the CarFactory. There can be many redefines of classes in practice. For instance a MercedesFactory probably would inhering from the CarFactory. Where the PorscheFactory inherits from the VolkswagenFactory, since there is overlap between the parts and behavior of Volkswagens and Porsches, the Mercedes is a totally different competing brand. If this structure of inheriting functionality is set up in a clever way – which is an design process in itself, it needs several generations of sketch code to understand how the best structure should be organized – then most of the code of a program can be reused to solve similar design problems, without copy-paste any of the code lines. The course will show how this works in use cases. This leads to the building of a set of classes that is very dedicated to the design practice. Let’s now look into some coding that draws. -------------------------------------------------------------------------- Drawing in DrawBot The left frame in the DrawBot window contains the drawing board, the canvas of the window. This is the area where the effect of the drawing instructions in visible. The DrawBot application has some functions defined that are not part of the Python language itself. They are only a available inside the DrawBot applications. That is why this manual is specifically showing these function in the context of the canvas. The size of the canvas is 1000 x 1000 point. If the drawing is supposed to cover a larger or smaller area, then the size of the canvas needs to be adjusted. That is done with the specific DrawBot method: size(300, 200) Putting this line on top of a program will for instance define a canvas of 3oo points wide and 200 points high. It is the page size of the application. The first argument to the size method is the requested width of the canvas, and the second argument to the size method is the requested height of the canvas. After executing the code line, the canvas is changed. This should be done before any other drawing method is called. And it can only be called once in a program. DrawBot knows about the drawing of some standard shapes. The rectangle we already saw before, in this course. Remember the code to draw four rectangles: stroke(0.5) fill(None) rect(10, 10, 200, 100) rect(10+200+10, 10, 200, 100) They did the work, but the program had a very inefficient structure. Changing their position or size or amount does include a lot of manual work, due to the fact that all values are numbers instead of variable. This would even increase further when the amount of rectangles changes. The other three standard shapes in DrawBot are oval(10, 10, 100, 100) oval(250, 10, 100, 200) to draw ovals and circles and ovals, line(0, 250, 200, 200) to draw single straight lines, and polygon(350, 250, 350, 350, 400, 450, 450, 350, 450, 250, close=True) to draw open and closed polygon shapes, arbitrary shapes with straight lines. Let’s have a close look at these standard shapes. Understanding how they work, makes it easier to write working code yourself. The rectangle rect( ) takes 4 arguments: x The horizontal position on the canvas y The vertical position on the canvas The width of the rectangle. That is a relative measure. So the position of the right side of the rectangle will be on x+width. The height of the rectangle. That is also a relative measure. So the position of the top of the rectangle will be on y+height. Note that the width and height can also be negative numbers. In that case the right side is on position x and the left side is on position x minus the width. You can imagine that the rectangle flipped in horizontal direction. The same applies vertical if the height is a negative number. If you want to draw a square, then just keep the width and height argument identical. It is relatively easy to add the square as function. This code does make the conversion. It is so simple, that it is hardly worth to implement it. But for clarity it also shows how the single width argument for the square is copied into both the width and the height arguments of the rectangle function. This way the width and height are always equal, now matter what the value of the width is. This results in drawing a square. def square(x, y, width): rect(x, y, width, width) Ovals work similar as rectangles. The arguments are identical to the arguments of the rectangle. x and y as position and width and height as proportion. The oval is drawn with the imaginary rectangle as bounding box. So, to draw a circle, the bounding box should be an exact square. However this is not conform the way we normally would position a circle: with middle point and radius. This function defines the behavior of a circle that way: def circle(mx, my, r): w = 2 * r # Calculate the width as the double of radius x = mx-r # Calculate the x and y from the center. y = my-r oval(x, y, w, w) # Draw the circle as normal oval The line is a simple entity that draws a straight line from one point to another. The function takes four arguments: the x and y of the starting point and the x and y of the end point. The color of the line is defined by the stroke(r, g, b) function and its thickness by the strokewidth(w) function. Where the r, g, b define the color in a fractional number between 0 and 1 (0 is black and 1 is full color) and the w is a value larger that 0. The line function is simple, but it allow to be combined into other functions such as an arrow, where the size argument defines the size of the arrow head. Also here the stroke and the strokewidth function define the color and the thickness of the line. def arrow(x1, y1, x2, y2, size, close=False): import math line(x1, y1, x2, y2) dx = x2 - x1 dy = y2 - y1 # Transform and rotate the canvas if dy != 0: lineangle = 180*math.atan(dx/dy)/math.pi else: lineangle = 90 translate(x2, y2) rotate(-lineangle+90) polygon(-size, size/2, 0, 0, -size, -size/2, close= close) rotate(lineangle-90) translate(-x2, -y2) The global description of what happens in the arrow function is as follows: Draw the main straight line of the arrow between start point and end point. Calculate the different between the x values of the start point and the end point. Then the dx variable holds the horizontal spanning distance of the main arrow line, independent from where the arrow is located on the canvas. Then the vertical difference between the start point and the end point is calculated, independent from where the arrow is located on the canvas. The dy variable now holds that value. Calculate the angle of the main line, since we need that to calculate the directions of the arrow head lines. The translate function will set the origin of drawing in the canvas to the end point of the arrow. We need to do that, because the the arrow head it drawn as horizontal lines, but then on a rotated canvas. This needs a bit of abstract thinking. Instead of drawing the lines of the arrow head to a point that is rotated according to the angle of the original line, it is easier to rotate the virtual canvas and then draw the arrow head as horizontal line. Then the two lines of the arrow head are drawn as polygon, a sequence of straight lines. There are several reasons to that, instead of drawing them as separate lines. The most important reason is that the lines are connected then, which results is drawing a really sharp point at the end of the arrow. If the lines would be drawn separate, then DrawBot would not draw their junction as sharp point. Note that when the point is too sharp, it is on a different position than the end point is. For large arrows with sharp head lines this may be a problem. It is left as an exercise to think about the strategy to solve this. The other reason to use the polygon function is that it is easier to fill the triangle with a separate color. So, by setting the fill and the close values, the appearance of the arrow head can be adjusted. Although the content of the function description may seem like an overload of code, the usage of the function is quite simple. Either type the code literally (that is the best way of learning a new language) of copy it from the attached file with chunks of template code. To show a range of arrows, execute the following code (under the definition of the arrow function). fill(1, 1, 1) stroke(0, 0, 0) sw = 1 size = 30 closed = True for x in range(0, 501, 50): sw += 1 strokewidth(sw) arrow(20, 20, x+20, 520, size, closed) fill(0, 0, 0) sw = 1 strokewidth(sw) size = 30 closed = True for y in range(0, 501, 50): sw += 1 strokewidth(sw) arrow(20, 20, 520, y+20, size, closed) This code sets the fill to white, the stroke to some random color and a with of 3 points. The size of the arrow is 30. With the setting of different parameter we can influence the size of the arrow head. For instance, if we set the fill(None) and the closed = False, then the arrow has an open head. If we set fill(1, 1, 1) and closed = True, then the head is an closed white triangle. If fill(0, 0, 0) and closed = True, then the arrow head is a filled black triangle. Before we continue with the more fundamental function, let’s have some fun with what we know so far. We examined rectangle, squares, circles and oval, lines and we made a new arrow shape. Drawing the path The shapes, so far, where limited. They are strict geometric shapes, without much freedom. In order to draw arbitrary shapes, more control is required. The programming pattern for that is the path. Think if a path as drawing by undertaking a journey. You start at some point, and for every next step in the path you can decide what the type of line is. You can choose between a moveto (going there), a lineto (drawing a straight line), curveto (drawing a Bezier curve segment) and the arcto (drawing an arc, part of a circle). At the end the path is closed and drawn. This process is very similar how letter shapes are defined and drawn in a font. Drawing text Drawing images The manual Grids 2.5D and 3D Graphs Design patterns Naming Design inheritence Random and other virtual knowledge patterns Mandelbrot Programming layouts Grid calculation Drawing grids Replacing InDesign Useful Finder stuff Data stuff Reading and writing XML Interfacing to other applications InDesign Illustrator Programming for the web Generating HTML Generating CSS and SASS Generating JavaScript (parameters) Generating canvas drawing Scripting for RoboFont Generating (web)fonts Scripting the backgrounds of the ABC course. Fun stuff Advanced What is next?

